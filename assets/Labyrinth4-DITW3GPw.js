import{j as e}from"./index-BNnDAQ_X.js";function n(){return e.jsxs("main",{className:"max-w-3xl mx-auto px-6 py-12 text-gray-800",children:[e.jsx("h1",{className:"text-4xl font-bold mb-2",children:"Phase 3: From Random Chaos to Structured Generation ‚Äî Evolving the Labyrinth System"}),e.jsx("p",{className:"text-gray-500 mb-8",children:"Posted on October 29, 2025"}),e.jsx("p",{className:"mb-6",children:"Following the progress in Phase 2, where the labyrinth grid first took shape through random tile placement and basic connection validation, the focus of this phase shifted toward structure, extensibility, and control. This was less about visual output, and more about engineering the system into something robust, testable, and expressive."}),e.jsx("h2",{className:"text-2xl font-semibold mb-4",children:"üß± Reassessing the Foundation"}),e.jsxs("p",{className:"mb-6",children:["The earlier implementation achieved visual results quickly ‚Äî it could fill a grid with tile prefabs and apply rotations to approximate connectivity. However, it became clear that the underlying design was too rigid. The generator‚Äôs logic was buried inside monolithic methods that directly instantiated ",e.jsx("code",{children:"GameObjects"}),", which made experimentation difficult. Each design tweak risked breaking the system because generation, validation, and presentation were tightly coupled."]}),e.jsx("blockquote",{className:"border-l-4 border-gray-400 pl-4 italic mb-6",children:"‚ÄúStop building tiles; start defining rules.‚Äù"}),e.jsx("h2",{className:"text-2xl font-semibold mb-4",children:"üß© Introducing the Constraint System"}),e.jsxs("p",{className:"mb-6",children:["The first major architectural shift came with the introduction of the"," ",e.jsx("code",{children:"ILabyrinthConstraint"})," interface ‚Äî a lightweight abstraction that represents a rule applied during generation."]}),e.jsx("p",{className:"mb-6",children:"Instead of hardcoding adjacency logic, the generator now queries a set of constraint objects that each implement a single validation rule. This approach allows constraints to be added, removed, or replaced without modifying the core generator."}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-lg mb-6 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed",children:`public interface ILabyrinthConstraint
{
    bool Validate(TileConnection[,] grid, int x, int y, TileType type, int rotation, TileConnection mask);
}`}),e.jsxs("p",{className:"mb-6",children:["The simplest example is the ",e.jsx("code",{children:"ConnectionConstraint"}),", which ensures that each tile aligns correctly with its neighbors‚Äô open paths:"]}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-lg mb-8 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed",children:`public class ConnectionConstraint : ILabyrinthConstraint
{
    public bool Validate(TileConnection[,] grid, int x, int y, TileType type, int rotation, TileConnection mask)
    {
        if (x > 0 && grid[x - 1, y] != 0)
        {
            var left = grid[x - 1, y];
            if (HasConnection(left, TileConnection.Right) != HasConnection(mask, TileConnection.Left))
                return false;
        }

        if (y > 0 && grid[x, y - 1] != 0)
        {
            var down = grid[x, y - 1];
            if (HasConnection(down, TileConnection.Up) != HasConnection(mask, TileConnection.Down))
                return false;
        }

        return true;
    }

    private static bool HasConnection(TileConnection mask, TileConnection dir)
        => (mask & dir) == dir;
}`}),e.jsx("p",{className:"mb-8",children:"With this in place, adjacency checks are no longer special-case logic inside the generator ‚Äî they‚Äôre just one of many possible constraints. This unlocks powerful future flexibility: tile distribution rules, symmetry constraints, difficulty scaling, or even narrative layout logic can all be defined the same way."}),e.jsx("h2",{className:"text-2xl font-semibold mb-4",children:"‚öôÔ∏è A Cleaner API Layer"}),e.jsxs("p",{className:"mb-6",children:["A second improvement came with the introduction of a dedicated entry point ‚Äî the"," ",e.jsx("code",{children:"LabyrinthGeneratorAPI"}),"."]}),e.jsx("p",{className:"mb-6",children:"Previously, generating a labyrinth required manually constructing the generator, adding constraints, and invoking its methods directly. That cluttered the gameplay code and made it harder to swap generation strategies later."}),e.jsx("p",{className:"mb-6",children:"The new API wraps this into a single clean call:"}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-lg mb-8 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed",children:`public static Tile[,] Generate(
    int gridSize, 
    TileType[] tileTypes, 
    Func<TileType, Tile> spawnTile, 
    params ILabyrinthConstraint[] constraints)
{
    var generator = new LabyrinthGenerator(tileTypes, gridSize);
    foreach (var c in constraints) generator.AddConstraint(c);
    generator.AddConstraint(new Constraints.ConnectionConstraint());
    return generator.Generate(gridSize, tileTypes, spawnTile);
}`}),e.jsx("p",{className:"mb-8",children:"This pattern ‚Äî lightweight factory on top of a modular generator ‚Äî strikes a strong balance between ease of use and extensibility."}),e.jsx("h2",{className:"text-2xl font-semibold mb-4",children:"üß† Logical Generation Before Physical Instantiation"}),e.jsx("p",{className:"mb-6",children:"A key strength of the earlier implementation was that tile prefabs were never instantiated until the full grid was completed. This design already avoided one of Unity‚Äôs most common procedural pitfalls ‚Äî the performance cost of constant creation and destruction cycles."}),e.jsx("p",{className:"mb-6",children:"However, even with that optimization, the process still treated visual tiles as the primary representation of the labyrinth. This phase introduced a conceptual shift: separating the logical grid from its visual layer."}),e.jsxs("p",{className:"mb-6",children:["Now, the generator first operates on an abstract data structure of"," ",e.jsx("code",{children:"TileConnection"})," masks. Each potential placement is validated purely in logic ‚Äî applying constraints, rotations, and adjacency checks ‚Äî before any GameObjects are spawned. Only once a tile type and rotation have been selected does the generator call the provided"," ",e.jsx("code",{children:"spawnTile"})," delegate to create the prefab:"]}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-lg mb-8 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed",children:`var (type, rotation, connectionMask) = PickValidTile(x, y, logicalGrid, tileTypes);
logicalGrid[x, y] = connectionMask;

var tile = spawnTile(type);
tile.type = type;
tile.name = $"{type.name}_{x}_{y}";
tile.SetRotation(rotation);`}),e.jsx("p",{className:"mb-8",children:"This dramatically reduces overhead, allowing the generator to scale up to larger grids or more complex constraint sets without performance issues."}),e.jsx("h2",{className:"text-2xl font-semibold mb-4",children:"üéÆ Integration with the Gameplay Layer"}),e.jsxs("p",{className:"mb-6",children:["On the gameplay side, the ",e.jsx("code",{children:"LabyrinthGrid"})," ",e.jsx("code",{children:"MonoBehaviour"})," was updated to integrate seamlessly with the new generation pipeline. It now uses the API directly, manages the spare tile mechanic, and handles shifting rows and columns with smooth coroutine-driven animation."]}),e.jsxs("p",{className:"mb-6",children:["A simple keyboard control scheme (",e.jsx("kbd",{children:"W"}),"/",e.jsx("kbd",{children:"A"}),"/",e.jsx("kbd",{children:"S"}),"/",e.jsx("kbd",{children:"D"}),") triggers the grid shifts, and the system now tracks previous moves to prevent immediate reversals ‚Äî a subtle but meaningful gameplay rule that enhances puzzle flow."]}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-lg mb-10 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed",children:`if (_hasPreviousMove && entryPoint == GetOppositePosition(_lastInsertPos))
{
    Debug.LogWarning("Cannot reverse previous insertion directly!");
    return;
}`}),e.jsx("h2",{className:"text-2xl font-semibold mb-4",children:"ü™û Design Reflections"}),e.jsx("p",{className:"mb-6",children:"Phase 3 marks a clear evolution from procedural enthusiasm to intentional architecture."}),e.jsxs("div",{className:"bg-gray-100 text-gray-800 p-6 rounded-lg shadow mb-8",children:[e.jsx("p",{className:"font-semibold mb-2",children:"Before ‚Üí Now"}),e.jsxs("ul",{className:"list-disc list-inside space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Before:"})," Generation was random, reactive, and hard to control.",e.jsx("br",{}),e.jsx("strong",{children:"Now:"})," Generation is rule-based, modular, and extensible."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Before:"})," Gameplay and generation logic were intertwined.",e.jsx("br",{}),e.jsx("strong",{children:"Now:"})," The generator is a self-contained system that can serve multiple gameplay contexts."]})]})]}),e.jsx("p",{className:"mb-6",children:"This phase also laid the foundation for more advanced features ‚Äî dynamic difficulty adjustment, thematic tile grouping, or even procedural level progression. By framing everything around constraints and rules, future expansion becomes a matter of composition, not refactoring."})]})}export{n as default};
