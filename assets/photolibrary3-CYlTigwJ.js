import{j as e}from"./index-B8yjoQuT.js";function a(){return e.jsxs("main",{className:"max-w-4xl mx-auto px-6 py-16 text-left",children:[e.jsx("h1",{className:"text-4xl sm:text-5xl font-extrabold text-gray-900 mb-10 text-center",children:"Learning Qt by Building: Threads, Signals, and Ownership"}),e.jsx("p",{className:"text-gray-500 mb-8 text-center italic",children:"Posted on 2025-12-10"}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"The Framework Choice"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:'I chose Qt for this project because I wanted to learn it properly. I’ve dabbled before, but "dabbling" in Qt usually means "copy-pasting from StackOverflow until the window shows up."'}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"This time, I wanted to understand the machine. And oh boy, did the machine fight back."}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"Thread Affinity: The Silent Killer"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"Coming from a generic C++ background, I assumed that if I had a pointer to an object, I could call methods on it."}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["Qt says: ",e.jsx("em",{children:'"No."'})]}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["I spent three days debugging a race condition where my UI would update ",e.jsx("em",{children:"sometimes"}),", but crash randomly. The culprit? ",e.jsx("strong",{children:"Thread Affinity"}),". In Qt, every ",e.jsx("code",{children:"QObject"}),' "lives" on a specific thread. If you call a method on it from another thread, you are breaking the law.']}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"The Signal/Slot Enlightenment"}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:['The solution—and the moment the framework finally "clicked" for me—was fully embracing ',e.jsx("strong",{children:"Signals and Slots"}),"."]}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["Instead of ",e.jsx("code",{children:"worker->doWork()"}),", you emit ",e.jsx("code",{children:"requestWork()"}),". Instead of the worker returning data, it emits ",e.jsx("code",{children:"workFinished(result)"}),"."]}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["It feels cumbersome at first. You’re writing boilerplate just to call a function. But then you realise what Qt is doing for you: ",e.jsx("strong",{children:"It’s marshaling the call across thread boundaries automatically."})," Use a queued connection, and the data arrives safely on the receiver's thread, with no mutex locking required in your business logic."]}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"MoveToThread() is Not Magic"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"One specific trap I fell into:"}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-xl mb-8 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed shadow-md",children:`// Current Thread: Main
MyWorker* worker = new MyWorker();      // Created on Main Thread
QThread* thread = new QThread();
worker->moveToThread(thread);           // Moved to Worker Thread
thread->start();`}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["I learned the hard way that the ",e.jsx("em",{children:"constructor"})," of ",e.jsx("code",{children:"MyWorker"})," still runs on the main thread. If you allocate sub-objects or timers in the constructor, they stay on the main thread, while the worker itself moves. The result is a Frankenstein object straddling two threads."]}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["Fixing this required a strict pattern: Do setup in a ",e.jsx("code",{children:"start()"})," slot, not the constructor."]}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:'It was a painful week, but my pipeline is now completely lock-free, relying entirely on message passing. It’s cleaner, safer, and arguably more "Qt" than anything I’ve written before.'}),e.jsx("img",{src:"/images/photoboss/parallel-working.png",alt:"Diagram showing multiple hash workers working in parallel on disk I/O results",className:"rounded-xl shadow-md mx-auto transform transition-transform duration-300 hover:scale-105 mb-10 w-full object-contain"})]})}export{a as default};
