import{j as e}from"./index-BRikjoy3.js";function s(){return e.jsx("main",{className:"max-w-3xl mx-auto px-6 py-16 text-gray-800",children:e.jsxs("article",{className:"prose prose-lg prose-gray max-w-none",children:[e.jsxs("h1",{className:"text-4xl font-extrabold text-gray-900 mb-2",children:["ğŸŒ€ Building a Living Labyrinth: Procedural Mazes Inspired by ",e.jsx("em",{children:"VerrÃ¼ckte Labyrinth"})]}),e.jsx("p",{className:"text-sm text-gray-500 mb-10",children:"Posted on 27-10-2025"}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"ğŸ§© A Classic Game Meets Code"}),e.jsxs("p",{children:["Last night, I was playing ",e.jsx("em",{children:"VerrÃ¼ckte Labyrinth"})," (also known as ",e.jsx("em",{children:"The aMAZEing Labyrinth"}),") with my daughter. As we slid tiles around the board and watched new paths appear, I couldnâ€™t stop thinking â€” this mechanic would be perfect for exploring procedural generation and tile-based systems in Unity."]}),e.jsxs("p",{children:["So, Iâ€™ve decided to turn that spark into a small side project (and blog series): ",e.jsx("strong",{children:"Building a Living Labyrinth"})," â€” a digital take on the board gameâ€™s ideas, built from the ground up with code, randomness, and a touch of design philosophy."]}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"ğŸ¯ Project Goal"}),e.jsxs("p",{children:["At its heart, ",e.jsx("em",{children:"VerrÃ¼ckte Labyrinth"})," is about structure and change. The maze exists as a grid of tiles, but every turn the shape of that maze can shift â€” entire rows move, new passages open, and others close. That mix of stability and chaos makes it a rich playground for procedural design."]}),e.jsxs("p",{children:["My goal for this series: ",e.jsx("strong",{children:"Create a Unity prototype"})," that procedurally generates and manipulates a tile-based labyrinth â€” inspired by the board gameâ€™s mechanics â€” and use it as a teaching tool for procedural generation."]}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"ğŸ§± The Core Idea: Tiles and Connectivity"}),e.jsx("p",{children:"The first concept to tackle is the tile system. Each tile in the game has a set of connections â€” pathways that can connect to other tiles. In the physical game, there are three archetypes:"}),e.jsxs("ul",{className:"list-disc list-inside",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Straight Tile"})," â€” connects two opposite edges (â”‚ or â”€)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Corner Tile"})," â€” connects two adjacent edges (â”, â””, etc.)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"T-Junction Tile"})," â€” connects three edges (â”œ, â”¬, etc.)"]})]}),e.jsx("p",{children:"Each tileâ€™s rotation determines how it fits into the labyrinth. So rather than hardcoding orientations, Iâ€™ll represent tiles by the sides they connect to â€” for example:"}),e.jsx("pre",{className:"bg-gray-900 text-gray-100 rounded-xl p-4 text-sm overflow-x-auto",children:`[Flags]
public enum TileConnection
{
    None = 0,
    Up = 1 << 0,
    Right = 1 << 1,
    Down = 1 << 2,
    Left = 1 << 3
}

// Example: a corner connecting Up and Right
TileConnection.Up | TileConnection.Right`}),e.jsx("p",{children:"This gives us a flexible, data-driven system â€” we can rotate, check connections, or even generate new tile types procedurally later."}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"â™»ï¸ The Grid and the â€œSpareâ€ Tile"}),e.jsx("p",{children:"The game board is a square grid â€” typically 7Ã—7 â€” with an extra tile off to the side. Hereâ€™s the fun part: that â€œspareâ€ tile can be inserted into any movable row or column, pushing the others forward and ejecting a tile on the opposite side."}),e.jsx("p",{children:"That mechanic turns the maze into a living system â€” part grid, part queue â€” where some tiles are fixed in place, and others shift dynamically each turn."}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"âš™ï¸ What Iâ€™ll Build First"}),e.jsxs("ul",{className:"list-disc list-inside",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Tile representation:"})," Create prefabs or scriptable objects for each tile type."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Grid management:"})," Build a simple GridManager to store tile states and positions."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Manual shifting:"})," Let a player click to push tiles and animate the change."]})]}),e.jsx("p",{children:"Thatâ€™s enough to recreate the feeling of the physical labyrinth. Once thatâ€™s working, I can start introducing procedural level generation â€” randomizing layouts while maintaining valid paths."}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"ğŸ§­ Looking Ahead"}),e.jsx("p",{children:"This is just the start. Hereâ€™s a rough roadmap for where Iâ€™d like to take this project:"}),e.jsx("div",{className:"overflow-x-auto my-4",children:e.jsxs("table",{className:"w-full border border-gray-300 text-left text-sm",children:[e.jsx("thead",{className:"bg-gray-100 font-semibold",children:e.jsxs("tr",{children:[e.jsx("th",{className:"p-2 border-b",children:"Phase"}),e.jsx("th",{className:"p-2 border-b",children:"Focus"}),e.jsx("th",{className:"p-2 border-b",children:"Description"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"1"}),e.jsx("td",{className:"p-2 border-b",children:"Tile System"}),e.jsx("td",{className:"p-2 border-b",children:"Represent and visualize tiles with rotation and connections"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"2"}),e.jsx("td",{className:"p-2 border-b",children:"Grid Logic"}),e.jsx("td",{className:"p-2 border-b",children:"Implement the shifting row/column mechanic"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"3"}),e.jsx("td",{className:"p-2 border-b",children:"Procedural Generation"}),e.jsx("td",{className:"p-2 border-b",children:"Randomly generate valid labyrinths"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"4"}),e.jsx("td",{className:"p-2 border-b",children:"Pathfinding"}),e.jsx("td",{className:"p-2 border-b",children:"Let a player (or AI) navigate the dynamic maze"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"5"}),e.jsx("td",{className:"p-2 border-b",children:"Extensions"}),e.jsx("td",{className:"p-2 border-b",children:"New maze rules, animations, and maybe an online demo"})]})]})]})}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"âœ¨ Why This Matters"}),e.jsxs("p",{children:["What excites me about ",e.jsx("em",{children:"VerrÃ¼ckte Labyrinth"})," as a programming project is that it blends data structures, procedural generation, and player interaction. Itâ€™s simple enough to code in a weekend, but deep enough to study for months."]}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"ğŸ§  Next Time"}),e.jsx("p",{children:"In the next post, Iâ€™ll dive into the tile system itself â€” setting up the data model and rendering tiles dynamically in Unity. Weâ€™ll start with a simple grid of randomly oriented tiles, and by the end of it, youâ€™ll be able to visualize the bones of your own living labyrinth."}),e.jsx("p",{className:"mt-8 text-blue-700 font-semibold",children:"Stay tuned â€” and if you have ideas for features or ways to visualize the shifting mechanic, Iâ€™d love to hear them!"})]})})}export{s as default};
