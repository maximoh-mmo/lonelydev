import{j as e}from"./index-BHUZ3rqh.js";function a(){return e.jsx("main",{className:"max-w-4xl mx-auto px-6 py-16 text-left",children:e.jsxs("article",{className:"prose prose-lg prose-gray max-w-none",children:[e.jsxs("h1",{className:"text-4xl sm:text-5xl font-extrabold text-gray-900 mb-10 text-center",children:["Building a Living Labyrinth: Procedural Mazes Inspired by ",e.jsx("em",{children:"Verr√ºckte Labyrinth"})]}),e.jsx("p",{className:"text-gray-500 mb-8 text-center italic",children:"Posted on October 27, 2025"}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"üß© A Classic Game Meets Code"}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["Last night, I was playing ",e.jsx("em",{children:"Verr√ºckte Labyrinth"})," (also known as ",e.jsx("em",{children:"The aMAZEing Labyrinth"}),") with my daughter. As we slid tiles around the board and watched new paths appear, I couldn‚Äôt stop thinking ‚Äî this mechanic would be perfect for exploring procedural generation and tile-based systems in Unity."]}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["So, I‚Äôve decided to turn that spark into a small side project (and blog series): ",e.jsx("strong",{children:"Building a Living Labyrinth"})," ‚Äî a digital take on the board game‚Äôs ideas, built from the ground up with code, randomness, and a touch of design philosophy."]}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"üéØ Project Goal"}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["At its heart, ",e.jsx("em",{children:"Verr√ºckte Labyrinth"})," is about structure and change. The maze exists as a grid of tiles, but every turn the shape of that maze can shift ‚Äî entire rows move, new passages open, and others close. That mix of stability and chaos makes it a rich playground for procedural design."]}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["My goal for this series: ",e.jsx("strong",{children:"Create a Unity prototype"})," that procedurally generates and manipulates a tile-based labyrinth ‚Äî inspired by the board game‚Äôs mechanics ‚Äî and use it as a teaching tool for procedural generation."]}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"üß± The Core Idea: Tiles and Connectivity"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"The first concept to tackle is the tile system. Each tile in the game has a set of connections ‚Äî pathways that can connect to other tiles. In the physical game, there are three archetypes:"}),e.jsxs("ul",{className:"list-disc list-inside mb-8 text-lg text-gray-700 leading-relaxed space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Straight Tile"})," ‚Äî connects two opposite edges (‚îÇ or ‚îÄ)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Corner Tile"})," ‚Äî connects two adjacent edges (‚îê, ‚îî, etc.)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"T-Junction Tile"})," ‚Äî connects three edges (‚îú, ‚î¨, etc.)"]})]}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"Each tile‚Äôs rotation determines how it fits into the labyrinth. So rather than hardcoding orientations, I‚Äôll represent tiles by the sides they connect to ‚Äî for example:"}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-xl mb-8 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed shadow-md",children:`[Flags]
public enum TileConnection
{
    None = 0,
    Up = 1 << 0,
    Right = 1 << 1,
    Down = 1 << 2,
    Left = 1 << 3
}

// Example: a corner connecting Up and Right
TileConnection.Up | TileConnection.Right`}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"This gives us a flexible, data-driven system ‚Äî we can rotate, check connections, or even generate new tile types procedurally later."}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"‚ôªÔ∏è The Grid and the ‚ÄúSpare‚Äù Tile"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"The game board is a square grid ‚Äî typically 7√ó7 ‚Äî with an extra tile off to the side. Here‚Äôs the fun part: that ‚Äúspare‚Äù tile can be inserted into any movable row or column, pushing the others forward and ejecting a tile on the opposite side."}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"That mechanic turns the maze into a living system ‚Äî part grid, part queue ‚Äî where some tiles are fixed in place, and others shift dynamically each turn."}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"‚öôÔ∏è What I‚Äôll Build First"}),e.jsxs("ul",{className:"list-disc list-inside mb-8 text-lg text-gray-700 leading-relaxed space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Tile representation:"})," Create prefabs or scriptable objects for each tile type."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Grid management:"})," Build a simple GridManager to store tile states and positions."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Manual shifting:"})," Let a player click to push tiles and animate the change."]})]}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"That‚Äôs enough to recreate the feeling of the physical labyrinth. Once that‚Äôs working, I can start introducing procedural level generation ‚Äî randomizing layouts while maintaining valid paths."}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"üß≠ Looking Ahead"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"This is just the start. Here‚Äôs a rough roadmap for where I‚Äôd like to take this project:"}),e.jsx("div",{className:"overflow-x-auto my-4 mb-8",children:e.jsxs("table",{className:"w-full border border-gray-300 text-left text-sm",children:[e.jsx("thead",{className:"bg-gray-100 font-semibold",children:e.jsxs("tr",{children:[e.jsx("th",{className:"p-2 border-b",children:"Phase"}),e.jsx("th",{className:"p-2 border-b",children:"Focus"}),e.jsx("th",{className:"p-2 border-b",children:"Description"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"1"}),e.jsx("td",{className:"p-2 border-b",children:"Tile System"}),e.jsx("td",{className:"p-2 border-b",children:"Represent and visualize tiles with rotation and connections"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"2"}),e.jsx("td",{className:"p-2 border-b",children:"Grid Logic"}),e.jsx("td",{className:"p-2 border-b",children:"Implement the shifting row/column mechanic"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"3"}),e.jsx("td",{className:"p-2 border-b",children:"Procedural Generation"}),e.jsx("td",{className:"p-2 border-b",children:"Randomly generate valid labyrinths"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"4"}),e.jsx("td",{className:"p-2 border-b",children:"Pathfinding"}),e.jsx("td",{className:"p-2 border-b",children:"Let a player (or AI) navigate the dynamic maze"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"5"}),e.jsx("td",{className:"p-2 border-b",children:"Extensions"}),e.jsx("td",{className:"p-2 border-b",children:"New maze rules, animations, and maybe an online demo"})]})]})]})}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"‚ú® Why This Matters"}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["What excites me about ",e.jsx("em",{children:"Verr√ºckte Labyrinth"})," as a programming project is that it blends data structures, procedural generation, and player interaction. It‚Äôs simple enough to code in a weekend, but deep enough to study for months."]}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"üß† Next Time"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"In the next post, I‚Äôll dive into the tile system itself ‚Äî setting up the data model and rendering tiles dynamically in Unity. We‚Äôll start with a simple grid of randomly oriented tiles, and by the end of it, you‚Äôll be able to visualize the bones of your own living labyrinth."}),e.jsx("p",{className:"text-lg text-blue-700 font-semibold mt-8 mb-8",children:"Stay tuned ‚Äî and if you have ideas for features or ways to visualize the shifting mechanic, I‚Äôd love to hear them!"})]})})}export{a as default};
