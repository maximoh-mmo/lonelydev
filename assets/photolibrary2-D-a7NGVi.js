import{j as e}from"./index-B8yjoQuT.js";function s(){return e.jsxs("main",{className:"max-w-4xl mx-auto px-6 py-16 text-left",children:[e.jsx("h1",{className:"text-4xl sm:text-5xl font-extrabold text-gray-900 mb-10 text-center",children:"From Idea to Architecture: Designing a Scalable Image Processing Pipeline"}),e.jsx("p",{className:"text-gray-500 mb-8 text-center italic",children:"Posted on 2025-11-26"}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"The Naive Approach"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"In my head, the logic was simple. Iterate through every folder, load every image, hash it, and check for duplicates. Easy, right?"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"I wrote the first prototype as a single loop. It worked beautifully for a test folder of 100 images. Then I pointed it at my main library of 50,000+ photos."}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"The UI froze immediately. The disk thrashing was audible from the next room. And when I finally killed the process, I realised I had no way to restart without beginning from zero."}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"Identifying the Bottlenecks"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:`I realised that "processing an image" isn't a single atomic action. It’s actually a series of very different operations, each with its own specific bottleneck:`}),e.jsxs("ul",{className:"list-disc list-inside mb-8 text-lg text-gray-700 leading-relaxed space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Scanning:"})," Fast, but disk-bound (seeking)."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Loading:"})," Extremely IO-heavy (sequential reads)."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Decoding:"})," CPU-heavy, variable time (JPEGs are messy)."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Hashing:"})," Pure math, CPU-bound."]})]}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"By running these in a single sequence, I was forcing my fast CPU to wait for the slow disk, and then forcing the idle disk to wait for the busy CPU. It was the worst of both worlds."}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"Thinking in Pipelines"}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["I threw out the single loop and redesigned the system as a ",e.jsx("strong",{children:"Pipeline"}),". Instead of one worker doing everything, I imagined a factory line."]}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["A ",e.jsx("strong",{children:"Scanner"})," thread runs ahead, finding files and tossing paths into a queue. A pool of ",e.jsx("strong",{children:"Loaders"})," grab paths, pull the data off the disk, and pass the raw buffers to a pool of ",e.jsx("strong",{children:"Decoders"}),". Finally, the ",e.jsx("strong",{children:"Hashers"})," do the math and send the results to the UI."]}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"This approach—Producer-Consumer queues connecting discrete stages—solved the responsiveness issue instantly. If the disk is slow, the hashers just pause. If the CPU is slammed, the scanners wait. The system naturally balances itself."}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"Why Structuring Matters"}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:['It’s tempting to "just use threads" (',e.jsx("code",{children:"std::async"})," is right there!), but raw threading quickly leads to a tangled mess of mutexes and race conditions."]}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["By enforcing a strict pipeline structure, I didn't just get performance. I got ",e.jsx("strong",{children:"sanity"}),'. Each stage has a single input and a single output. I can test the "Decoder" stage in isolation without needing a valid disk system. I can swap out the "Scanner" for a test harness.']}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"The architecture was set. Now I just had to implement it in Qt without shooting myself in the foot."}),e.jsx("img",{src:"/images/photoboss/pipeline-diagram.png",alt:"High-level image processing pipeline showing stages and data flow",className:"rounded-xl shadow-md mx-auto transform transition-transform duration-300 hover:scale-105 mb-10 w-full object-contain"})]})}export{s as default};
