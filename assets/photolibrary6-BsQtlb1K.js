import{j as e}from"./index-BHUZ3rqh.js";function s(){return e.jsxs("main",{className:"max-w-4xl mx-auto px-6 py-16 text-left",children:[e.jsx("h1",{className:"text-4xl sm:text-5xl font-extrabold text-gray-900 mb-10 text-center",children:"Designing a Persistent Hash Cache with SQLite"}),e.jsx("p",{className:"text-gray-500 mb-8 text-center italic",children:"Posted on 2026-01-21"}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"Identity without Reading"}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["The core challenge of a cache is trust. If I ask the database ",e.jsx("em",{children:'"Do you know the hash for Photo.jpg?"'}),", and it says ",e.jsx("em",{children:'"Yes,"'})," I need to be 100% certain that ",e.jsx("code",{children:"Photo.jpg"})," hasn't changed since that hash was calculated."]}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"But I can't read the file to check, because reading the file is the exact thing I'm trying to avoid."}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"The solution is a proxy identity. I assume a file is unchanged if three values remain constant:"}),e.jsxs("ul",{className:"list-disc list-inside mb-8 text-lg text-gray-700 leading-relaxed space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Absolute Path"})," (Location)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Size in Bytes"})," (Magnitude)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Last Modified Time"})," (History)"]})]}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"Is it theoretically possible to modify a file while keeping its size and timestamp exactly the same? Yes. Is it likely to happen to my family vacation photos? No."}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"The Schema"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"Designing the database felt like putting together a puzzle. I didn't want a single flat table. I wanted a system that could handle multiple hash algorithms (MD5, pHash, BlockMean) for the same file."}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"I settled on a normalised 3-table structure:"}),e.jsxs("ul",{className:"list-disc list-inside mb-8 text-lg text-gray-700 leading-relaxed space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Files Table:"}),' Stores the Path, Size, and MTime. This is the "Key".']}),e.jsxs("li",{children:[e.jsx("strong",{children:"Methods Table:"}),' Stores the name of the algorithm (e.g., "pHash") and its ',e.jsx("em",{children:"Version"}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Hashes Table:"})," The glue. It links a File to a Method and stores the Blob data."]})]}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"This separation is powerful. If I update my pHash calculation code, I just bump the version number in the Methods table. The app will see the version mismatch and automatically re-compute the new hashes, while leaving the MD5 hashes untouched."}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"The Cache as a Pipeline Member"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"The best part of this design? The cache isn't some side-car process. Itâ€™s just another stage in the pipeline."}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["The ",e.jsx("strong",{children:"CacheLookup"}),' stage sits right after the Scanner. It checks the DB. If it gets a hit, it sends the result directly to the UI, bypassing the heavy "loading" and "hashing" stages entirely. It feels like cheating.']}),e.jsx("img",{src:"/images/photoboss/sql-schema.png",alt:"SQLite schema for the hash cache",className:"rounded-xl shadow-md mx-auto transform transition-transform duration-300 hover:scale-105 mb-10 w-full object-contain"})]})}export{s as default};
