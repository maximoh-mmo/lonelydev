import{j as e}from"./index-vpKu_s3s.js";function r(){return e.jsxs("main",{className:"max-w-3xl mx-auto px-6 py-12 text-gray-800",children:[e.jsx("h1",{className:"text-4xl font-bold mb-2",children:"Learning Qt by Building: Threads, Signals, and Ownership"}),e.jsx("p",{className:"text-gray-500 mb-8",children:"Posted on 2025-12-10"}),e.jsx("h2",{className:"text-2xl font-semibold mb-4",children:"Why Qt?"}),e.jsx("p",{className:"mb-6",children:"Qt was chosen for several reasons:"}),e.jsxs("ul",{className:"list-disc list-inside mb-8 space-y-1",children:[e.jsx("li",{children:"Mature cross-platform support"}),e.jsx("li",{children:"Integrated UI and concurrency tools"}),e.jsx("li",{children:"A signal/slot model well-suited to pipelines"}),e.jsx("li",{children:"Strong documentation and ecosystem"})]}),e.jsx("p",{className:"mb-8",children:"However, Qt is not a thin abstraction. It has opinions — especially about object ownership and threading."}),e.jsx("h2",{className:"text-2xl font-semibold mb-4",children:"Key Qt Concepts I Had to Internalise"}),e.jsx("p",{className:"mb-6",children:"Some of the most important lessons:"}),e.jsxs("ul",{className:"list-disc list-inside mb-8 space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Thread affinity matters"}),e.jsx("br",{}),"Every QObject belongs to a specific thread."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Signals and slots are the right abstraction"}),e.jsx("br",{}),"They handle thread boundaries safely and cleanly."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"moveToThread() is powerful but dangerous"}),e.jsx("br",{}),"It changes where code executes, not who owns the object."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Lifetime management is critical"}),e.jsx("br",{}),"Qt’s parent–child ownership model is simple, but unforgiving if misused."]})]}),e.jsx("h2",{className:"text-2xl font-semibold mb-4",children:"Early Mistakes (and Fixes)"}),e.jsx("p",{className:"mb-6",children:"I initially made several common mistakes:"}),e.jsxs("ul",{className:"list-disc list-inside mb-8 space-y-1",children:[e.jsx("li",{children:"Accessing objects from the wrong thread"}),e.jsx("li",{children:"Confusing execution context with data ownership"}),e.jsx("li",{children:"Overusing shared mutable state"})]}),e.jsx("p",{className:"mb-8",children:"Refactoring toward a message-passing model simplified the system dramatically. Once each pipeline stage communicated exclusively via signals, the design became easier to reason about — and far more robust."}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-lg mb-10 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed",children:`// Example QObject moved to a worker thread and connected via signals
QThread* workerThread = new QThread;
Worker* worker = new Worker;

worker->moveToThread(workerThread);

QObject::connect(workerThread, &QThread::started,
                 worker, &Worker::process);

QObject::connect(worker, &Worker::finished,
                 workerThread, &QThread::quit);

workerThread->start();`}),e.jsx("img",{src:"/images/photoboss/parallel-working.png",alt:"Diagram showing multiple hash workers working in parallel on disk I/O results",className:"rounded-lg shadow-lg mb-10 w-full object-contain"})]})}export{r as default};
