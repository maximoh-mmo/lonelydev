import{j as e}from"./index-B8yjoQuT.js";function a(){return e.jsxs("main",{className:"max-w-4xl mx-auto px-6 py-16 text-left",children:[e.jsx("h1",{className:"text-4xl sm:text-5xl font-extrabold text-gray-900 mb-10 text-center",children:"Short-Circuiting Work: Introducing a Persistent Hash Cache"}),e.jsx("p",{className:"text-gray-500 mb-8 text-center italic",children:"Posted on 2026-01-27"}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"The Implementation"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"In my last post, I designed the schema for my cache. Now it was time to wire it up."}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:'The "Identity" problem was the first hurdle. I needed a way to fingerprint a file without reading it. I settled on a composite key:'}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-xl mb-8 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed shadow-md",children:`// Any change to these fields invalidates cached hashes
struct FileIdentity {
    QString path;
    quint64 sizeBytes;
    quint64 modifiedTime;
};`}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"Is it theoretically possible to modify a file while keeping its size and timestamp exactly the same? Yes. Is it likely to happen to my family vacation photos? No."}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"For the database itself, I needed a schema that could handle multiple hash algorithms per file. I used a normalised approach:"}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-xl mb-8 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed shadow-md",children:`-- Files table (The Identity)
CREATE TABLE files (
    id INTEGER PRIMARY KEY,
    path TEXT NOT NULL,
    size_bytes INTEGER NOT NULL,
    mtime_unix INTEGER NOT NULL,
    UNIQUE(path, size_bytes, mtime_unix)
);

-- Hashes table (The Expensive Work)
CREATE TABLE hashes (
    file_id INTEGER NOT NULL,
    hash_method_id INTEGER NOT NULL,
    value BLOB NOT NULL,
    PRIMARY KEY (file_id, hash_method_id)
);`}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"This is where the pipeline architecture I fought for in Part 2 really paid off. If I had written a spaghetti-code loop, adding caching would have been a nightmare of `if` statements."}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"Instead, I just inserted a new node in the graph:"}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-xl mb-8 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed shadow-md",children:`Scanner --> CacheLookup
CacheLookup -->|Hit| ResultAggregation
CacheLookup -->|Miss| DiskLoader`}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:["The ",e.jsx("code",{children:"CacheLookup"}),' worker takes a file path, queries SQLite, and makes a decision. If the hash exists, it creates a "Job Done" signal and sends it straight to the finish line. The disk loader never even knows the file existed.']}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"The First Run"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"I implemented the SQLite backend, set up the WAL (Write-Ahead Logging) for concurrency, and fired it up."}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:[e.jsx("strong",{children:"Run 1:"})," 45 minutes. (Expected. It had to hash everything from scratch)."]}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"Then, the moment of truth. I closed the app. Re-opened it. And pointed it at the same 50,000 photos."}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:[e.jsx("strong",{children:"Run 2:"})," 4 seconds."]}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:'I actually laughed out loud. The bottleneck had shifted entirely from "Parsing JPEGs" to "How fast can SQLite return rows?" (Answer: very fast).'}),e.jsx("h2",{className:"text-2xl font-semibold text-gray-900 mb-4",children:"Runtime Config"}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:'Because I versioned the hash methods in the database, I could now do something cool: I added a "Settings" dialog where I could toggle individual algorithms on and off.'}),e.jsxs("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:['Want to only use MD5 for speed? Uncheck "Perceptual Hash." The pipeline adjusts instantly. Re-enable it? The system checks the cache, sees the missing values for ',e.jsx("em",{children:"that specific algorithm"}),", and schedules jobs to compute only the missing data."]}),e.jsx("p",{className:"text-lg text-gray-700 mb-8 leading-relaxed",children:"It felt like I had finally tamed the beast. The infrastructure was solid. Now I could finally focus on the actual goal: finding the duplicates."})]})}export{a as default};
