import{j as e}from"./index-akp9ZBEU.js";function s(){return e.jsx("main",{className:"max-w-3xl mx-auto px-6 py-16 text-gray-800",children:e.jsxs("article",{className:"prose prose-lg prose-gray max-w-none",children:[e.jsxs("h1",{className:"text-4xl font-extrabold text-gray-900 mb-2",children:["🌀 Building a Living Labyrinth: Procedural Mazes Inspired by ",e.jsx("em",{children:"Verrückte Labyrinth"})]}),e.jsx("p",{className:"text-gray-500 mb-8",children:"Posted on October 27, 2025"}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"🧩 A Classic Game Meets Code"}),e.jsxs("p",{children:["Last night, I was playing ",e.jsx("em",{children:"Verrückte Labyrinth"})," (also known as ",e.jsx("em",{children:"The aMAZEing Labyrinth"}),") with my daughter. As we slid tiles around the board and watched new paths appear, I couldn’t stop thinking — this mechanic would be perfect for exploring procedural generation and tile-based systems in Unity."]}),e.jsxs("p",{children:["So, I’ve decided to turn that spark into a small side project (and blog series): ",e.jsx("strong",{children:"Building a Living Labyrinth"})," — a digital take on the board game’s ideas, built from the ground up with code, randomness, and a touch of design philosophy."]}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"🎯 Project Goal"}),e.jsxs("p",{children:["At its heart, ",e.jsx("em",{children:"Verrückte Labyrinth"})," is about structure and change. The maze exists as a grid of tiles, but every turn the shape of that maze can shift — entire rows move, new passages open, and others close. That mix of stability and chaos makes it a rich playground for procedural design."]}),e.jsxs("p",{children:["My goal for this series: ",e.jsx("strong",{children:"Create a Unity prototype"})," that procedurally generates and manipulates a tile-based labyrinth — inspired by the board game’s mechanics — and use it as a teaching tool for procedural generation."]}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"🧱 The Core Idea: Tiles and Connectivity"}),e.jsx("p",{children:"The first concept to tackle is the tile system. Each tile in the game has a set of connections — pathways that can connect to other tiles. In the physical game, there are three archetypes:"}),e.jsxs("ul",{className:"list-disc list-inside",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Straight Tile"})," — connects two opposite edges (│ or ─)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Corner Tile"})," — connects two adjacent edges (┐, └, etc.)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"T-Junction Tile"})," — connects three edges (├, ┬, etc.)"]})]}),e.jsx("p",{children:"Each tile’s rotation determines how it fits into the labyrinth. So rather than hardcoding orientations, I’ll represent tiles by the sides they connect to — for example:"}),e.jsx("pre",{className:"bg-gray-900 text-green-300 text-sm p-4 rounded-lg mb-6 overflow-x-auto text-left font-mono whitespace-pre leading-relaxed",children:`[Flags]
public enum TileConnection
{
    None = 0,
    Up = 1 << 0,
    Right = 1 << 1,
    Down = 1 << 2,
    Left = 1 << 3
}

// Example: a corner connecting Up and Right
TileConnection.Up | TileConnection.Right`}),e.jsx("p",{children:"This gives us a flexible, data-driven system — we can rotate, check connections, or even generate new tile types procedurally later."}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"♻️ The Grid and the “Spare” Tile"}),e.jsx("p",{children:"The game board is a square grid — typically 7×7 — with an extra tile off to the side. Here’s the fun part: that “spare” tile can be inserted into any movable row or column, pushing the others forward and ejecting a tile on the opposite side."}),e.jsx("p",{children:"That mechanic turns the maze into a living system — part grid, part queue — where some tiles are fixed in place, and others shift dynamically each turn."}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"⚙️ What I’ll Build First"}),e.jsxs("ul",{className:"list-disc list-inside",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Tile representation:"})," Create prefabs or scriptable objects for each tile type."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Grid management:"})," Build a simple GridManager to store tile states and positions."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Manual shifting:"})," Let a player click to push tiles and animate the change."]})]}),e.jsx("p",{children:"That’s enough to recreate the feeling of the physical labyrinth. Once that’s working, I can start introducing procedural level generation — randomizing layouts while maintaining valid paths."}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"🧭 Looking Ahead"}),e.jsx("p",{children:"This is just the start. Here’s a rough roadmap for where I’d like to take this project:"}),e.jsx("div",{className:"overflow-x-auto my-4",children:e.jsxs("table",{className:"w-full border border-gray-300 text-left text-sm",children:[e.jsx("thead",{className:"bg-gray-100 font-semibold",children:e.jsxs("tr",{children:[e.jsx("th",{className:"p-2 border-b",children:"Phase"}),e.jsx("th",{className:"p-2 border-b",children:"Focus"}),e.jsx("th",{className:"p-2 border-b",children:"Description"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"1"}),e.jsx("td",{className:"p-2 border-b",children:"Tile System"}),e.jsx("td",{className:"p-2 border-b",children:"Represent and visualize tiles with rotation and connections"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"2"}),e.jsx("td",{className:"p-2 border-b",children:"Grid Logic"}),e.jsx("td",{className:"p-2 border-b",children:"Implement the shifting row/column mechanic"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"3"}),e.jsx("td",{className:"p-2 border-b",children:"Procedural Generation"}),e.jsx("td",{className:"p-2 border-b",children:"Randomly generate valid labyrinths"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"4"}),e.jsx("td",{className:"p-2 border-b",children:"Pathfinding"}),e.jsx("td",{className:"p-2 border-b",children:"Let a player (or AI) navigate the dynamic maze"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"p-2 border-b",children:"5"}),e.jsx("td",{className:"p-2 border-b",children:"Extensions"}),e.jsx("td",{className:"p-2 border-b",children:"New maze rules, animations, and maybe an online demo"})]})]})]})}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"✨ Why This Matters"}),e.jsxs("p",{children:["What excites me about ",e.jsx("em",{children:"Verrückte Labyrinth"})," as a programming project is that it blends data structures, procedural generation, and player interaction. It’s simple enough to code in a weekend, but deep enough to study for months."]}),e.jsx("h2",{className:"text-2xl font-semibold mt-10 mb-4",children:"🧠 Next Time"}),e.jsx("p",{children:"In the next post, I’ll dive into the tile system itself — setting up the data model and rendering tiles dynamically in Unity. We’ll start with a simple grid of randomly oriented tiles, and by the end of it, you’ll be able to visualize the bones of your own living labyrinth."}),e.jsx("p",{className:"mt-8 text-blue-700 font-semibold",children:"Stay tuned — and if you have ideas for features or ways to visualize the shifting mechanic, I’d love to hear them!"})]})})}export{s as default};
